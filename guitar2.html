<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CG Guitar Training</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .string-display-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0.75rem;
        }
        .string-box {
            border-radius: 0.5rem;
            text-align: center;
            padding: 0.75rem 0.25rem;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            border: 2px solid transparent;
        }
        .string-box .string-name {
            font-weight: bold;
            font-size: 1.25rem;
        }
        .string-box .note-name {
            font-size: 0.875rem;
            font-weight: 500;
        }
        .string-box .finger-name {
            font-size: 0.75rem;
            font-style: italic;
            opacity: 0.8;
            height: 1em;
        }
        .string-correct { background-color: #10b981; color: white; border-color: #059669;}
        .string-incorrect { background-color: #ef4444; color: white; border-color: #b91c1c;}
        .string-muted { background-color: #facc15; color: #78350f; border-color: #d97706;}
        .string-neutral { background-color: #e5e7eb; color: #4b5563; border-color: #d1d5db;}
        .string-off { background-color: #6b7280; color: #d1d5db; border-color: #4b5563;}

        .progress-bar-container {
            background-color: #e5e7eb;
            border-radius: 9999px;
            height: 1.5rem;
            width: 100%;
            overflow: hidden;
        }
        .progress-bar-fill {
            background-color: #3b82f6;
            height: 100%;
            transition: width 0.3s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .audio-level-container {
            background-color: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            height: 1rem;
            width: 100%;
            overflow: hidden;
            margin-top: 1rem;
        }
        .audio-level-bar {
            background-color: #3b82f6;
            height: 100%;
            width: 0%;
            transition: width 0.1s linear;
        }
        .lang-btn {
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            transition: background-color 0.2s;
        }
        .lang-btn.active {
            background-color: #3b82f6;
            color: white;
            font-weight: bold;
        }
        .lang-btn:not(.active) {
            color: #6b7280;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 min-h-screen flex flex-col items-center pt-8 px-4">

    <div id="custom-message-box" class="message-box" style="display:none; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: #f8d7da; color: #721c24; padding: 1rem 1.5rem; border: 1px solid #f5c6cb; border-radius: 0.375rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 1000; font-size: 0.9rem;"></div>

    <div class="w-full max-w-4xl bg-white shadow-xl rounded-lg p-6 md:p-8">
        <header class="text-center mb-8 relative">
            <h1 id="app-title" class="text-3xl md:text-4xl font-bold text-blue-600"></h1>
            <p id="app-subtitle" class="text-gray-600 mt-2"></p>
            <div class="absolute top-0 right-0 bg-gray-200 p-1 rounded-lg text-sm">
                <span id="lang-btn-id" class="lang-btn">ID</span>
                <span id="lang-btn-en" class="lang-btn">EN</span>
            </div>
        </header>

        <section id="mic-controls" class="mb-8 p-6 bg-gray-50 rounded-lg shadow">
            <h2 id="mic-title" class="text-2xl font-semibold mb-4 text-center text-blue-500"></h2>
            <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
                <button id="start-btn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow transition duration-150 ease-in-out w-full sm:w-auto"></button>
                <button id="stop-btn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow transition duration-150 ease-in-out w-full sm:w-auto" disabled></button>
            </div>
            <div class="mt-4">
                <label id="audio-input-label" class="block text-sm font-medium text-gray-700 text-center"></label>
                <div class="audio-level-container">
                    <div id="audio-level-bar" class="audio-level-bar"></div>
                </div>
            </div>
        </section>

        <section id="practice-selection" class="mb-8 p-6 bg-gray-50 rounded-lg shadow">
            <h2 id="selection-title" class="text-2xl font-semibold mb-4 text-center text-blue-500"></h2>
            <div class="flex justify-center">
                 <select id="target-chord-select" class="w-full max-w-xs bg-white border border-gray-300 text-gray-700 py-3 px-4 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                </select>
            </div>
        </section>

        <section id="live-feedback" class="p-6 bg-white rounded-lg shadow-inner border border-gray-200">
            <h2 id="feedback-title" class="text-2xl font-semibold mb-6 text-center text-gray-700"></h2>
            
            <div id="accuracy-section" class="mb-6">
                <h3 id="accuracy-title" class="text-lg font-medium text-gray-600 mb-2"></h3>
                <div class="progress-bar-container">
                    <div id="accuracy-bar" class="progress-bar-fill" style="width: 0%;">0%</div>
                </div>
                 <p id="accuracy-text" class="text-center text-gray-500 mt-2"></p>
            </div>

            <div class="mb-6">
                <h3 id="string-analysis-title" class="text-lg font-medium text-gray-600 mb-2"></h3>
                <div id="string-analysis-display" class="string-display-grid"></div>
            </div>

            <div>
                <h3 id="suggestion-title" class="text-lg font-medium text-gray-600 mb-2"></h3>
                <div id="suggestion-box" class="bg-blue-50 p-4 rounded-lg min-h-[50px] text-center text-blue-800">
                    <p></p>
                </div>
            </div>
        </section>

        <footer class="text-center mt-8 text-sm text-gray-500">
            <p id="footer-text"></p>
        </footer>
    </div>

<script>
// --- Polyfill & Message Box (Unchanged) ---
if (!window.AudioContext && window.webkitAudioContext) window.AudioContext = window.webkitAudioContext;
function showMessage(message, type = 'error', duration = 3000) { /* Unchanged */ }

class PracticeTool {
    constructor() {
        this.audioContext = new AudioContext();
        this.noteFrequencies = this.getAllNoteFrequencies(); 
        this.chordStringDatabase = this.buildChordStringDatabase();
        // this.bufferSize = 4096; 
        this.bufferSize = 4096*8; 
        this.confidenceThreshold = -65;
        this.sourceNode = null;
        this.analyser = null;
        this.isDetecting = false;
        this.animationFrameId = null;
        this.maxAllowedDeviationRatio = 0.08; 
        this.currentTargetChord = 'C'; // --- UPDATED: Default chord is now C
        
        this.currentLanguage = 'id';
        this.languageData = this.getLanguageData();
        
        this.lastAnalysisResult = null;
        this.stabilityCounter = 0;
        this.requiredStability = 4;

        this.isSuggestionActive = false;
    }

    // --- Core Audio Methods ---
    async start() {
        if (this.isDetecting) return;
        if (this.audioContext.state === "suspended") { await this.audioContext.resume(); }
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            this.sourceNode = this.audioContext.createMediaStreamSource(stream);
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = this.bufferSize;
            this.analyser.smoothingTimeConstant = 0.8;
            this.analyser.minDecibels = -100;
            this.analyser.maxDecibels = -20;
            this.sourceNode.connect(this.analyser);
            this.isDetecting = true;
            document.getElementById("start-btn").disabled = true;
            document.getElementById("stop-btn").disabled = false;
            this.analyzeLoop();
        } catch (error) {
            console.error("Error accessing microphone:", error);
            const msg = this.languageData[this.currentLanguage].micError;
            showMessage(msg, "error");
            this.isDetecting = false;
        }
    }

    stop() {
        if (!this.isDetecting) return;
        this.isDetecting = false;
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
        if (this.sourceNode) {
            this.sourceNode.mediaStream.getTracks().forEach(track => track.stop());
            try { this.sourceNode.disconnect(); } catch (e) {}
        }
        document.getElementById("start-btn").disabled = false;
        document.getElementById("stop-btn").disabled = true;
        this.resetFeedbackUI();
    }

    // --- Main Analysis Loop ---
    analyzeLoop() {
        if (!this.isDetecting) return;

        const dataArray = new Float32Array(this.analyser.frequencyBinCount);
        this.analyser.getFloatFrequencyData(dataArray);
        
        const audioLevelBar = document.getElementById('audio-level-bar');
        if (audioLevelBar) {
            let maxVolume = -Infinity;
            dataArray.forEach(v => { if (v > maxVolume) maxVolume = v; });
            const volumePercent = 100 * (1 - (maxVolume / this.analyser.minDecibels));
            audioLevelBar.style.width = `${Math.min(100, Math.max(0, volumePercent))}%`;
        }

        const isAudioPresent = dataArray.some(value => value > this.confidenceThreshold);

        if (!isAudioPresent) {
            if (this.stabilityCounter > 0) {
                 this.resetFeedbackUI(false); 
            }
            this.stabilityCounter = 0;
        } else {
            const detectedNotesData = this.getDetectedNotesAndFrequencies(dataArray);
            const analysis = this.analyzePracticeAttempt(detectedNotesData, this.currentTargetChord);

            const analysisString = JSON.stringify(analysis.stringAnalysis);
            if (analysisString === this.lastAnalysisResult) {
                this.stabilityCounter++;
            } else {
                this.stabilityCounter = 0;
                this.lastAnalysisResult = analysisString;
            }

            if (this.stabilityCounter >= this.requiredStability) {
                this.updateFeedbackUI(analysis);
                this.updateSuggestionUI(analysis);
            }
        }
        this.animationFrameId = requestAnimationFrame(() => this.analyzeLoop());
    }
    
    // --- Practice Logic (Unchanged) ---
    analyzePracticeAttempt(detectedNotesData, targetChordId) {
        const expectedChordData = this.chordStringDatabase[targetChordId];
        const stringNames = ["E2", "A2", "D3", "G3", "B3", "E4"];
        let stringAnalysis = {};
        let detectedNotesClone = [...detectedNotesData];
        let assignedStrings = new Set();
        let assignedDetectedNotes = new Set();
        let potentialMatches = [];

        stringNames.forEach(stringName => {
            const expectedNoteFullName = expectedChordData.notes[stringName];
            if (expectedNoteFullName !== "Muted") {
                const targetFreq = this.noteFrequencies.find(nf => nf[0] === expectedNoteFullName)[1];
                detectedNotesClone.forEach((detectedNote, detectedNoteIndex) => {
                    let diff = Math.abs(detectedNote.freq - targetFreq);
                    if (stringName === 'E2' && detectedNote.name === 'E3') diff = 5;
                    if (stringName === 'A2' && detectedNote.name === 'E4') diff = 10;
                    potentialMatches.push({ stringName, expectedNote: expectedNoteFullName, detectedNote, detectedNoteIndex, diff });
                });
            }
        });

        potentialMatches.sort((a, b) => a.diff - b.diff);

        potentialMatches.forEach(match => {
            if (!assignedStrings.has(match.stringName) && !assignedDetectedNotes.has(match.detectedNoteIndex)) {
                if (match.diff < 45) {
                    let isCorrect = (match.detectedNote.name === match.expectedNote);
                    if (match.stringName === "E2" && match.detectedNote.name === "E3") isCorrect = true;
                    stringAnalysis[match.stringName] = isCorrect ? 'correct' : 'incorrect';
                    assignedStrings.add(match.stringName);
                    assignedDetectedNotes.add(match.detectedNoteIndex);
                }
            }
        });
        
        let totalPlayableNotes = 0;
        let correctlyPlayedNotes = 0;
        let incorrectlyMutedStrings = 0;

        stringNames.forEach(stringName => {
            const expectedNote = expectedChordData.notes[stringName];
            if (expectedNote !== "Muted") {
                totalPlayableNotes++;
                if (assignedStrings.has(stringName) && stringAnalysis[stringName] === 'correct') {
                    correctlyPlayedNotes++;
                }
            }
        });
        
        const remainingNotes = detectedNotesClone.filter((_, index) => !assignedDetectedNotes.has(index));
        stringNames.forEach(stringName => {
             if (expectedChordData.notes[stringName] === "Muted") {
                const standardFreq = this.noteFrequencies.find(nf => nf[0] === stringName)[1];
                if (remainingNotes.some(note => Math.abs(note.freq - standardFreq) < 30)) {
                    incorrectlyMutedStrings++;
                    stringAnalysis[stringName] = 'incorrect';
                } else {
                    stringAnalysis[stringName] = 'correct';
                }
            } else if (!assignedStrings.has(stringName)) {
                stringAnalysis[stringName] = 'muted';
            }
        });
        
        let baseAccuracy = (totalPlayableNotes > 0) ? (correctlyPlayedNotes / totalPlayableNotes) : 1;
        let penalty = incorrectlyMutedStrings * 0.15;
        const accuracy = Math.round(Math.max(0, baseAccuracy - penalty) * 100);

        return { accuracy, stringAnalysis };
    }
    
    // --- UI functions ---
    updateFeedbackUI(analysis) {
        const { accuracy, stringAnalysis } = analysis;
        
        let displayAccuracy = accuracy;
        let displayAnalysis = { ...stringAnalysis };
        const lang = this.languageData[this.currentLanguage];
        const currentThreshold = this.chordStringDatabase[this.currentTargetChord].threshold || 75;

        if (accuracy >= currentThreshold) {
            displayAccuracy = 100;
            const expectedChordData = this.chordStringDatabase[this.currentTargetChord];
            const stringNames = ["E2", "A2", "D3", "G3", "B3", "E4"];
            stringNames.forEach(stringName => {
                const expectedNote = expectedChordData.notes[stringName];
                if (expectedNote === "Muted") {
                    displayAnalysis[stringName] = stringAnalysis[stringName] === 'incorrect' ? 'incorrect' : 'correct';
                } else {
                    displayAnalysis[stringName] = 'correct';
                }
            });
        }
        
        document.getElementById('accuracy-bar').style.width = `${displayAccuracy}%`;
        document.getElementById('accuracy-bar').textContent = `${displayAccuracy}%`;
        
        const accuracyBar = document.getElementById('accuracy-bar');
        if (displayAccuracy === 100) { accuracyBar.style.backgroundColor = '#10b981'; }
        else if (displayAccuracy > 30) { accuracyBar.style.backgroundColor = '#f59e0b'; }
        else { accuracyBar.style.backgroundColor = '#ef4444'; }
        
        const accuracyText = document.getElementById('accuracy-text');
        if (accuracy >= currentThreshold) { accuracyText.textContent = lang.feedbackGood; }
        else if (accuracy > 30) { accuracyText.textContent = lang.feedbackOk; }
        else { accuracyText.textContent = lang.feedbackBad; }

        const displayOrder = ["E2", "A2", "D3", "G3", "B3", "E4"]; // --- UPDATED: Reversed order
        displayOrder.forEach(stringName => {
            const stringBox = document.getElementById(`string-box-${stringName}`);
            if (stringBox) {
                const status = displayAnalysis[stringName] || "neutral";
                if (status === 'correct' && this.chordStringDatabase[this.currentTargetChord].notes[stringName] === 'Muted') {
                    stringBox.className = 'string-box string-off';
                } else {
                    stringBox.className = `string-box string-${status}`;
                }
            }
        });
    }
    
    resetFeedbackUI(fullReset = true) {
        document.getElementById('audio-level-bar').style.width = '0%';
        const accuracyBar = document.getElementById('accuracy-bar');
        if(accuracyBar) {
            accuracyBar.style.width = '0%';
            accuracyBar.textContent = '0%';
        }
        document.getElementById('accuracy-text').textContent = this.languageData[this.currentLanguage].strumPrompt;
        this.renderStringAnalysisUI(this.currentTargetChord);
        
        if (fullReset) {
            this.isSuggestionActive = false;
            this.resetSuggestionUI();
        }
    }

    resetSuggestionUI() {
        document.getElementById('suggestion-box').innerHTML = `<p>${this.languageData[this.currentLanguage].suggestionReady}</p>`;
    }

    updateSuggestionUI(analysis) {
        if (this.isSuggestionActive || this.stabilityCounter < this.requiredStability) {
            return;
        }

        const suggestionHTML = this.generateSuggestionText(analysis);
        
        if (suggestionHTML) {
            const suggestionBox = document.getElementById('suggestion-box');
            suggestionBox.innerHTML = `<p>${suggestionHTML}</p>`;
            this.isSuggestionActive = true;

            setTimeout(() => {
                this.isSuggestionActive = false;
                this.resetSuggestionUI();
            }, 2500); 
        }
    }
    
    generateSuggestionText(analysis) {
        const { accuracy, stringAnalysis } = analysis;
        const lang = this.languageData[this.currentLanguage];
        const currentThreshold = this.chordStringDatabase[this.currentTargetChord].threshold || 75;
        const stringOrder = ["E2", "A2", "D3", "G3", "B3", "E4"];
        
        if (accuracy >= currentThreshold) {
            return lang.suggestionPerfect;
        }

        for (const stringName of stringOrder.reverse()) { // Still check from thin to thick for priority
            const status = stringAnalysis[stringName];
            if (status === "muted") {
                const fingerInfo = this.chordStringDatabase[this.currentTargetChord].fingering[stringName];
                const fingerName = fingerInfo ? lang.fingering[fingerInfo.fingerKey] : '';
                const template = fingerInfo ? lang.suggestionMutedFretted : lang.suggestionMutedOpen;
                return template.replace('{finger}', `<strong>${fingerName}</strong>`).replace('{string}', `<strong>${stringName.slice(0,-1)}</strong>`);
            } else if (status === "incorrect") {
                return lang.suggestionIncorrect.replace('{string}', `<strong>${stringName.slice(0,-1)}</strong>`);
            }
        }
        if (accuracy > 0) return lang.suggestionAlmost;
        return '';
    }

    renderStringAnalysisUI(targetChordId) {
        const display = document.getElementById('string-analysis-display');
        const expectedChordData = this.chordStringDatabase[targetChordId];
        if (!display || !expectedChordData) return;
        
        display.innerHTML = '';
        const stringNames = ["E2", "A2", "D3", "G3", "B3", "E4"]; // --- UPDATED: Reversed order for display
        const lang = this.languageData[this.currentLanguage];
        
        stringNames.forEach(stringName => {
            const noteForString = expectedChordData.notes[stringName] || "N/A";
            const fingerInfo = expectedChordData.fingering[stringName];
            const fingerForString = fingerInfo ? lang.fingering[fingerInfo.fingerKey] : "&nbsp;";

            const stringBox = document.createElement('div');
            stringBox.id = `string-box-${stringName}`;
            stringBox.innerHTML = `
                <div class="string-name">${stringName.slice(0, -1)}</div>
                <div class="note-name">${noteForString}</div>
                <div class="finger-name">${fingerForString}</div>`;
            
            stringBox.className = (noteForString === "Muted") ? 'string-box string-off' : 'string-box string-neutral';
            display.appendChild(stringBox);
        });
    }
    
    // --- Data and Language Functions ---
    getAllNoteFrequencies() { const noteNames=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"],allNotes=[],A4=440; for(let o=0;o<=7;o++){for(let t=0;t<noteNames.length;t++){const e=noteNames[t]+o,n=(o-4)*12+t-9,a=A4*Math.pow(2,n/12);a>=20&&a<=5e3&&allNotes.push([e,a])}}return allNotes }
    getDetectedNotesAndFrequencies(dataArray) { const noteStrengths = {}; for (let i = 0; i < dataArray.length; i++) { const frequencyBin = i * this.audioContext.sampleRate / this.analyser.fftSize; if (frequencyBin < 60 || frequencyBin > 1400) continue; const amplitude = dataArray[i]; if (amplitude > this.confidenceThreshold) { const closestStandardNoteData = this.findClosestStandardNote(frequencyBin); if (closestStandardNoteData) { const noteName = closestStandardNoteData[0]; if (!noteStrengths[noteName] || amplitude > noteStrengths[noteName].amp) { noteStrengths[noteName] = { name: noteName, freq: frequencyBin, amp: amplitude }; } } } } return Object.values(noteStrengths).sort((a, b) => b.amp - a.amp).slice(0, 8); }
    findClosestStandardNote(frequency) { let closestNoteMatch = null, minDistance = Infinity; for (const noteFreqPair of this.noteFrequencies) { const [noteName, standardFreq] = noteFreqPair; const distance = Math.abs(standardFreq - frequency); if (distance < minDistance) { minDistance = distance; closestNoteMatch = noteFreqPair; } } if (closestNoteMatch && (minDistance < closestNoteMatch[1] * this.maxAllowedDeviationRatio)) { return closestNoteMatch; } return null; }
    
    buildChordStringDatabase() {
        return {
            "C": { notes: { E4: "E4", B3: "C4", G3: "G3", D3: "E3", A2: "C3", E2: "Muted" }, fingering: { B3: { fingerKey: "index" }, D3: { fingerKey: "middle" }, A2: { fingerKey: "ring" } }, threshold: 100 },
            "G": { notes: { E4: "G4", B3: "B3", G3: "G3", D3: "D3", A2: "B2", E2: "G2" }, fingering: { E2: { fingerKey: "middle" }, A2: { fingerKey: "index" }, E4: { fingerKey: "ring" } }, threshold: 50 },
            "D": { notes: { E4: "F#4", B3: "D4", G3: "A3", D3: "D3", A2: "Muted", E2: "Muted" }, fingering: { G3: { fingerKey: "index" }, E4: { fingerKey: "middle" }, B3: { fingerKey: "ring" } }, threshold: 55 },
            "A": { notes: { E4: "E4", B3: "C#4", G3: "A3", D3: "E3", A2: "A2", E2: "Muted" }, fingering: { D3: { fingerKey: "index" }, G3: { fingerKey: "middle" }, B3: { fingerKey: "ring" } }, threshold: 60 },
            "E": { notes: { E4: "E4", B3: "B3", G3: "G#3", D3: "E3", A2: "B2", E2: "E2" }, fingering: { G3: { fingerKey: "index" }, A2: { fingerKey: "middle" }, D3: { fingerKey: "ring" } }, threshold: 50 },
            "Am": { notes: { E4: "E4", B3: "C4", G3: "A3", D3: "E3", A2: "A2", E2: "Muted" }, fingering: { B3: { fingerKey: "index" }, D3: { fingerKey: "middle" }, G3: { fingerKey: "ring" } }, threshold: 60 },
            "Em": { notes: { E4: "E4", B3: "B3", G3: "G3", D3: "E3", A2: "B2", E2: "E2" }, fingering: { A2: { fingerKey: "index" }, D3: { fingerKey: "middle" } }, threshold: 50 },
            "Dm": { notes: { E4: "F4", B3: "D4", G3: "A3", D3: "D3", A2: "Muted", E2: "Muted" }, fingering: { E4: { fingerKey: "index" }, G3: { fingerKey: "middle" }, B3: { fingerKey: "ring" } }, threshold: 80 },
            "F": { notes: { E4: "F4", B3: "C4", G3: "A3", D3: "F3", A2: "C3", E2: "F2" }, fingering: { E2: { fingerKey: "barre" }, E4: { fingerKey: "barre" }, B3: { fingerKey: "barre" }, G3: { fingerKey: "middle" }, A2: { fingerKey: "ring" }, D3: { fingerKey: "pinky" } }, threshold: 55 },
            "F (Easy)": { notes: { E4: "F4", B3: "C4", G3: "A3", D3: "F3", A2: "Muted", E2: "Muted" }, fingering: { B3: { fingerKey: "index" }, E4: { fingerKey: "index" }, G3: { fingerKey: "middle" }, D3: { fingerKey: "ring" } }, threshold: 65 },
            "Bm": { notes: { E4: "F#4", B3: "D4", G3: "B3", D3: "F#3", A2: "B2", E2: "Muted" }, fingering: { A2: { fingerKey: "barre" }, B3: { fingerKey: "middle" }, D3: { fingerKey: "pinky" }, G3: { fingerKey: "ring" } }, threshold: 60 },
            "Bm (Easy)": { notes: { E4: "B3", B3: "D4", G3: "B3", D3: "Muted", A2: "Muted", E2: "Muted" }, fingering: { E4: { fingerKey: "index" }, G3: { fingerKey: "middle" }, B3: { fingerKey: "ring" } }, threshold: 65 }
        };
    }

    formatChordName(chordId) { 
        const lang = this.languageData[this.currentLanguage];
        let name = chordId;
        if (chordId.includes("(Easy)")) {
            name = name.replace(" (Easy)", ` (${lang.easy})`);
        }
        if (name.includes("m")) {
            name = name.replace('m', ` ${lang.minor}`);
        } else {
            if (!name.includes(lang.minor)) {
                 name = `${name} ${lang.major}`;
            }
        }
        return name;
    }

    populatePracticeSelect() {
        const selectEl = document.getElementById('target-chord-select');
        selectEl.innerHTML = '';
        Object.keys(this.chordStringDatabase).forEach(chordId => {
            const option = document.createElement('option');
            option.value = chordId;
            option.textContent = this.formatChordName(chordId);
            selectEl.appendChild(option);
        });
        selectEl.value = this.currentTargetChord;
    }

    setLanguage(lang) {
        if (!this.languageData[lang]) return;
        this.currentLanguage = lang;
        document.documentElement.lang = lang;

        const text = this.languageData[lang];
        document.title = text.pageTitle;
        document.getElementById('app-title').textContent = text.appTitle;
        document.getElementById('app-subtitle').textContent = text.appSubtitle;
        document.getElementById('mic-title').textContent = text.micTitle;
        document.getElementById('start-btn').textContent = text.startBtn;
        document.getElementById('stop-btn').textContent = text.stopBtn;
        document.getElementById('audio-input-label').textContent = text.audioInputLabel;
        document.getElementById('selection-title').textContent = text.selectionTitle;
        document.getElementById('feedback-title').textContent = text.feedbackTitle;
        document.getElementById('accuracy-title').textContent = text.accuracyTitle;
        document.getElementById('string-analysis-title').textContent = text.stringAnalysisTitle;
        document.getElementById('suggestion-title').textContent = text.suggestionTitle;
        document.getElementById('footer-text').textContent = text.footerText;
        
        document.getElementById('lang-btn-id').classList.toggle('active', lang === 'id');
        document.getElementById('lang-btn-en').classList.toggle('active', lang === 'en');

        this.populatePracticeSelect();
        this.resetFeedbackUI(true);
    }
    
    getLanguageData() {
        return {
            'id': {
                pageTitle: "CG Guitar Training",
                appTitle: "CG Guitar Training Practice Tool",
                appSubtitle: "Pilih chord untuk berlatih dan dapatkan feedback langsung untuk setiap senar.",
                micTitle: "Kontrol Audio",
                startBtn: "Mulai Mikrofon",
                stopBtn: "Hentikan Mikrofon",
                audioInputLabel: "Input Audio Langsung",
                selectionTitle: "Pilih Chord Latihan",
                feedbackTitle: "Live Feedback",
                accuracyTitle: "Akurasi Chord",
                stringAnalysisTitle: "Analisis Senar",
                suggestionTitle: "Saran",
                footerText: "© 2025 CG Guitar Training. Selamat berlatih.",
                strumPrompt: "Lakukan strumming pada chord untuk melihat akurasi Anda.",
                suggestionReady: "Siap untuk strumming berikutnya.",
                major: "Mayor",
                minor: "Minor",
                easy: "Mudah",
                feedbackGood: "Bagus sekali!",
                feedbackOk: "Hampir tepat!",
                feedbackBad: "Perlu latihan lagi.",
                suggestionPerfect: "Sempurna! Suaranya terdengar jauh lebih baik.",
                suggestionAlmost: "Sudah hampir benar! Lakukan strumming lebih jelas lagi.",
                suggestionMutedFretted: "Sepertinya jari {finger} Anda kurang menekan senar {string}.",
                suggestionMutedOpen: "Pastikan senar {string} yang terbuka berbunyi nyaring. Periksa apakah ada jari lain yang menyentuhnya.",
                suggestionIncorrect: "Periksa kembali posisi jari Anda pada senar {string}.",
                micError: "Akses mikrofon ditolak atau terjadi error. Silakan periksa izin pada browser Anda.",
                fingering: { index: "Telunjuk", middle: "Tengah", ring: "Manis", pinky: "Kelingking", barre: "Telunjuk (Barre)" }
            },
            'en': {
                pageTitle: "CG Guitar Training",
                appTitle: "CG Guitar Training Practice Tool",
                appSubtitle: "Select a chord to practice and get live feedback for each string.",
                micTitle: "Audio Controls",
                startBtn: "Start Microphone",
                stopBtn: "Stop Microphone",
                audioInputLabel: "Live Audio Input",
                selectionTitle: "Select Chord to Practice",
                feedbackTitle: "Live Feedback",
                accuracyTitle: "Chord Accuracy",
                stringAnalysisTitle: "String Analysis",
                suggestionTitle: "Suggestions",
                footerText: "© 2025 CG Guitar Training. Happy practicing.",
                strumPrompt: "Strum the selected chord to see your accuracy.",
                suggestionReady: "Ready for the next strum.",
                major: "Major",
                minor: "Minor",
                easy: "Easy",
                feedbackGood: "Excellent!",
                feedbackOk: "Almost there!",
                feedbackBad: "Needs more practice.",
                suggestionPerfect: "Perfect! The sound is much better.",
                suggestionAlmost: "You're on the right track! Strum a little clearer.",
                suggestionMutedFretted: "It seems your {finger} finger isn't pressing the {string} string firmly enough.",
                suggestionMutedOpen: "Make sure the open {string} string rings out. Check if another finger is touching it.",
                suggestionIncorrect: "Check your finger placement on the {string} string.",
                micError: "Microphone access was denied or an error occurred. Please check your browser permissions.",
                fingering: { index: "Index", middle: "Middle", ring: "Ring", pinky: "Pinky", barre: "Index (Barre)" }
            }
        };
    }
}

// --- Global Instance and Event Listeners ---
let practiceTool = null;

document.addEventListener('DOMContentLoaded', () => {
    practiceTool = new PracticeTool();
    
    document.getElementById("start-btn").addEventListener("click", () => practiceTool.start());
    document.getElementById("stop-btn").addEventListener("click", () => practiceTool.stop());
    
    document.getElementById('target-chord-select').addEventListener('change', (e) => {
        practiceTool.currentTargetChord = e.target.value;
        practiceTool.renderStringAnalysisUI(e.target.value);
        practiceTool.resetFeedbackUI(true);
    });
    
    document.getElementById('lang-btn-id').addEventListener('click', () => practiceTool.setLanguage('id'));
    document.getElementById('lang-btn-en').addEventListener('click', () => practiceTool.setLanguage('en'));

    practiceTool.setLanguage('id');
});
</script>
</body>
</html>
